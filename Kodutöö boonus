Boonusülesanne: Koormustegur ja Rehashing (Double hashing vs Rehashing)


1. Räsitabeli koormustegur ja selle olulisus
   
   Räsitabeli koormustegur on suhe aktiivsete elementide arvu ja tabeli suuruse vahel. 

  Koormustegur = aktiivsete elementide arv/tabeli suurus

 Koormustegur näitab, kui palju räsitabel on täidetud või "koormatud". Kui koormustegur on suur, tähendab see, et räsitabel on lähemal täitumisele, mis omakorda suurendab konfliktide ja aja komplekssuse riski. 
 Ideaalne olukord on, kui koormustegur on madal ja tabel on piisavalt suur, et vältida liigset konflikte.

2. Rehashingu protsess ja selle efektiivsus

   Rehashing on protsess, kus räsitabelit suurendatakse või vähendatakse ning olemasolevad elemendid jaotatakse ümber uue suurusega tabelis. 
   Üks lihtne rehashingu meetod on lihtsalt kahekordistada tabeli suurus, kui koormustegur ületab teatud piiri.

   Näiteks, kui koormustegur ületab 0.7, võime kahekordistada tabeli suurust ja seejärel liigutada iga olemasoleva elemendi uude tabelisse. 
   See protsess vähendab koormustegurit, hoides ära liigset täitmist ja konflikte.

3. Rehashingu mõju räsitabeli jõudlusele

   Rehashingu eelised ja puudused:

   - Eelised
     - Vähendab konflikte Suurendades tabeli suurust või kasutades muid rehashingu meetodeid, vähendab see olemasolevate elementide vahelisi konflikte.
     - Säilitab efektiivsuse: Hoolikalt valitud rehashingu strateegia võib aidata säilitada räsitabeli efektiivsust pikema aja jooksul.

   - Puudused
     - Aeg- ja ressursinõudlik
       Rehashing võib olla kulukas operatsioon, eriti suurte tabelite korral, kus palju elemente tuleb ümber paigutada.
     - Mõjutab ajalist jõudlust
       Rehashingu ajal on räsitabel ajutiselt "lukus", mistõttu võivad tekkida ajutised jõudlusküsimused, eriti kiiresti muutuvas keskkonnas.

   Kokkuvõttes on rehashing kasulik strateegia, kui seda rakendatakse õigesti, et säilitada räsitabeli efektiivsus ja ennetada liigset koormust.



  Lihtne Rehashing Pythonis

   def rehash(old_table):
       new_size = 2 * len(old_table)  # Uus suurus võib olla näiteks kaks korda suurem
       new_table = [None] * new_size

       for item in old_table:
           if item is not None:
               hash_value = hash_function(item, new_size)
               while new_table[hash_value] is not None:
                   hash_value = (hash_value + 1) % new_size  # Lineaarne sondimine
               new_table[hash_value] = item

       return new_table
   

   Funktsioon loob uue räsitabeli, kasutades uut suurust ja liigutab olemasolevad elemendid uude tabelisse, kasutades uut räsifunktsiooni ja käsitleb kollisioone vajadusel.

