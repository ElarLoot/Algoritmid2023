Kahendotsingu (Binary Search) rakendamine ja analüüs

def binary_search(arr, x):
    low = 0
    high = len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == x:
            return mid
        elif arr[mid] < x:
            low = mid + 1
        else:
            high = mid - 1
    return -1  # Kui elementi pole massiivis

sorted_array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
search_element = 6
tulemus = binary_search(sorted_array, search_element)

if tulemus != -1:
    print(f"Element {search_element} leiti indeksilt {tulemus}.")
else:
    print(f"Element {search_element} ei leitud massiivist.")


Aegkomplekssuse võrdlus teoreetilises analüüsis

Lineaarotsingu (Linear Search) aegkomplekssus on O(n), kus n on massiivi pikkus. Kahendotsingu (Binary Search) aegkomplekssus on O(log n), kus log on logaritm alusel. 
Seega on kahendotsing tavaliselt oluliselt kiirem suurte andmemahtude puhul võrreldes lineaarotsinguga.


Näide stsenaariumist, kus Binary Search on kasulikum kui Linear Search

Binary Search on kasulikum juhul, kui massiiv on suur ja sorteeritud. Näiteks, kui meil on suur telefoniraamat ja soovime leida konkreetse isiku telefoni numbri, on kahendotsing efektiivsem kui lineaarotsing. 
Lineaarotsingu korral peaksime kontrollima igat kirjet järjestikku, samas kui kahendotsing võimaldab kiiresti välistada pool massiivist iga sammu järel, vähendades see läbi oluliselt vajalike sammude arvu.

Linear Search peab vaatama igat elementi järjestikku, mistõttu võtab see aega O(n).
Binary Search saab iga sammuga välistada poole massiivist, vähendades otsimiseks vajalikke samme logaritmilise keerukusega O(log n). Seega, mida suurem on massiiv, seda suurem on Binary Search'i eelis.




    
